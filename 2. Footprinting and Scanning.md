# Footprinting and Scanning

Goal: Deepin the knowledge of the in-scope servers and services. Fingerprinting. Want to find the OS, purpose of the IP, importance host has to the client. Map the network environment.

Help to understand how the network is composed and thus, how to effectively mount our future attacks. 

## Storing information

Map the network hosts -> Track services and ports -> note firewalls, routers, other nodes. 

 Tools: 

## refernce information

 [Ports, protocols, and service info](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)
 
 ## Notes and best practises
 
 Network admins may deploy anti-enumeration techniques and may deploy services on other ports or ports that commonly identifies with malware. 
 Run multiple scans, using different techniques. 
 
 Depending on the time you have for the pentest and the client agreement, a quiet or faster (louder) scan may be needed.
 
 --packet-trace nmap option allows you to see a list of every packet send and received with nmap. 
 
 # Scanning

 ## Host discovery and Network mapping:
 
  
 ping sweep for live assets:
  
      nmap –sn <target>
        
        target can be a NET/CIDR or "–iL hostslist.txt" to invoke using a list of ranges
        
  Note that some networks block ping / do not allow certain servers to respond to ping, therefore this should not be the only way to determine live hosts.
  
   Is a good idea to run a quick sS scan against common ports to the same range
   
    nmap -sS <target>
  
  Then you will want top discover the OS running on each node and chart the OS detected from nmap and its confidence and apply your own judgement. 
  
   Active OS fingerprinting with nmap
   
      nmap -Pn –O <targets>
      
        -O: Enable OS detection
        --osscan-limit: Limit OS detection to promising targets
        --osscan-guess: Guess OS more aggressively

   Offline passive OS fingerprinting can be done with [P0f](http://lcamtuf.coredump.cx/p0f3/)
   
 <img width="656" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85520739-4fcf4f00-b5d1-11ea-94d5-9be3fa61b155.PNG">

    
  ## Port scanning to find what daemons and services are running on each node
     - NMAP
      
       -sS and -U scans 
        
     - Masscan
     
        meant for larger networks. Faster than nmap, however can be less accurate.
        
  <img width="654" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85521045-b2284f80-b5d1-11ea-999d-b56886804e11.PNG">      
  <img width="620" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85521432-3da1e080-b5d2-11ea-97e8-27bc14040afb.PNG">
  
  nmap port status notes:
  
  **TCP**
  - Open: port is open
  - Closed: a RST-ACK was received
  - Filtered: No response (likely a firewall) or an ICMP unreachable error is returned as a response.
 
 **UDP**
 - Open: Target responds to our request, we send ICMP destination unreachable (port unreachable) to close connection
 - Closed: Target may respond with ICMP destination unreachable (port unreachable)
 -
 
 ### Idle scan / zombie scan  -sI
   
   A scan technique that involves the presence of a zombie in the target network. A zombie is a host that is not sending or reciveing any packets.
   
   We will send fragmented packets to the target with src of the zombie, probing the fragment ID of the zombie should tell us if the port is open or not on the target depending if the fragments ID has been incremented. 

   Uses (fragmentation)[https://github.com/Kahvi-0/General-Notes/blob/master/Networking/Fragmentation.md] IDs against the zombie to infer if the port is open or closed on our target. 
   
   Pre-reqs:
   
   1. Zombie that assings IP ID both incrementally and globablly
   2. Find idle zombie, i.e no other traffic on the zombie that will disturb the IP ID. 
   
 Finding a zombie: 
 
     nmap -O -v -n <IP>
    
   If the result comes back with "IP ID Sequence Generation: Incremental", then that is a good zombie.
   
  
 **Scan details:**

 **Probing**

  1. probe zombie IP frag ID by sending SYN/ACK to it
  2. Since communication is not expected, the zombie will respond with RST and its IP Frag ID
  3. Forge a SYN packet (IP spoofing) with the zombie source IP and sind it to the target. 
   
**Open port results**

  4. target sends a SYN/ACK to the zombie
  5. Zombie does not expect this and sends a RST back to the target and increments its IP frag ID.
  6. Attacker probs the zombies IP frag ID (as seen above). 
  7. Zombie responds with RST. We should see that the IP frag ID has incremented by 2 (from the initial probe).
   
 <img width="549" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85524478-34b30e00-b5d6-11ea-8e5a-af4265246b02.PNG">

**Close port results**

  4. target sends a RST and the zombie ignores it, not incrementing the IP frag ID.
  5. Attacker probes again the zombies IP ID.
  6. The zombie sends us a RST and we see that the IP frag ID has only incremented by 1.
     
<img width="626" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85524798-7d6ac700-b5d6-11ea-93f9-00b4220009e1.PNG">
     
 Command example: 

      nmap -Pn -sI <zombie IP> <target IP>:<port> -v
 
###  FTP bounce scan  -b 

 Exploits an FTP servers PORT command, if an FTP server is vulnerable, we can launch a por tscan from the FTP server to other machines( maybe even a way to bypass into an internal network.  
 
### TCP NULL (sN), FIN (sF), Xmans (sX)

 These exploit a loophole in the TCP RFC in order to differntiate between open and closed ports. Id adest port is closed, an incoming packet segment not containing a RST, causes a RST to be sent as a response. Also, packets sent to open ports without SYN, RST, or ACK bits set, should be dropped and the packets should be returned. 
 
 So if a TCP RFC compliant system receives a packet without SYN, ACK, or RST bits then return: RST if the port is closed or no response if the port is open.
 Note, as long as the none of the 3 require bits are included (SYN, ACK,RST), any combo of the other bits  (FIN, PSH, URG) are acceptable. 
 
 Nmap uses the following scans to take advantage of this loophole. 
 
  - NUll: does not send any bits, TCP flag header is 0
  
  - FIN: only sets the FIN bit
  
  - Xmas: sends FIN, PSH, and URG flags 
  
These used to be a way to evade firewalls and packet filtering. Now with stateful firewalls and IDS', the stealth in these techniques have been eliminated. 
Note that major OS (MS, cisco IOS, Unix based) now send RST regardless. In addition sometimes scans cannot determine if filtered or open, so it will be labled "open|filtered" meaning more testing needs to be done to determine the ports state. 
 
### IP protocol scan -sO 
 
 Not a port scan. Enumerates the types of IP protocol that a target system supports. Walks through the 8-bit IP protocol field. It looks out for the ICMP procol uncreachable messages to, any seen then nmap marks that protocol as open. 
 
## Firewalls and evasion 

If stealth is needed, tools like nmap offer some ways that can help. 

 **Evasion**
 
 hping and nping can be used to craft packets that can be used to help evade firewalls
 
 **Techniques:**

- Fragmentation: Can disable the ability of some firewall and IDS systems to either apply packet filtering or fingerprinting them or to process all the fragments. i.e it may look at one fragment, but never the packet as a whole. (Note modern IDS can rebuild fragmented packets)
  
    To use:  nmap -sS -f  #note this does not work with -sT and -sV
    
     Can also specify the mtu with  --mtu  #note the offset must be a multiple of eight.

- Decoys: Aim is to add noise to the IDS by sending scans from spoofed IP addresses, confusing the analyst watching the system, making IDing the attacker harder.

   Requires the following: All decoys are up and running (otherwise its easy to see who the real attacker is), the real IP addresses should appear in random order, ISP's traversed by spoofed traffic let the traffic go through.

      nmap -sS -D <decoy1>, <decoy2>, <me> <target>  #cannot use with -sT or -sV

- Timing: Slows down the scan to blend into other traffic in the logs and possibly the IDS port scan detection.

<img width="674" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85558488-c763a500-b5f6-11ea-8ff8-c99f851c96fa.PNG">

<img width="361" alt="Capture" src="https://user-images.githubusercontent.com/46513413/85558548-d5b1c100-b5f6-11ea-8e5f-8676d05f21be.PNG">

- Source ports: Used to abuse poorly configured firewalls that allow traffic from certain ports. For example a firewall may allow only traffic from port 20 and 53. We can cahnge our source port to bypass this restriction. 

      nmap --source-port <port>
           -g <port>

More nmap methods to bypass firewalls: https://nmap.org/book/man-bypass-firewalls-ids.html


### TCP ACK scan  -sA

Not used to determine open ports, its used to map the rulesets of the firewalls and determine if the devices are both stateful and which ports are filtered. 
Open and closed ports will return a RST and be marked as unfiltered. Ports that do not respond will be marked as filtered. 

### TCPwrapped

   Signs during a network scan that indicate something is blocking connectivity:
   
    Service scan might not pick up the version of common services though the port is open
    
    service type not recognized
      
      This can show up as "tcpwrapped" meaning that the TCP handshake was completed but the remote host closed the connection without receiving any data.
  
  Using the nmap option "--reason" will explain why a port is marked open or closed.
  
 


 
 
## nmap NSE

stored: /usr/share/nmap/scripts/

    --script 
    
    --script-updatedb  #update scripts
    
    --script-help "service*" and 

Information gathering uses: 

    --script whois 
  
OS discovery 

    --script smb-os-discovery -p 445
    
    --script default  #default scripts, smb, OS discovery
    
## Service and OS detection

**Banner grabbing** is the message the server sends back when another host tries to est a connection to it. Many banners contain versions of the service by default. Should not be 100% relied on.

**Probing services** is more accurate. nmap does this with its service detection features. It parses responses and verifies if there is a signatrue match against a DB for services. (nmap -sV)

**OS fingerprinting** 

 - Active: Sends packets and waits for response. (nmap -O)
 
    - Ref: http://phrack.org/issues/54/9.html#article
           https://nmap.org/book/osdetect.html
 
 - Passive: Analyze captured traffic from target to determine OS without sending anything.
 
   Tool: P0f http://lcamtuf.coredump.cx/p0f3/
     Gathers the following info without sending a packet:
     
      - Host uptime
      - OS / software
      - distance (TTL)
      - UA
      - etc
      
    to run it on kali:  p0f -i eth0 
 
## Vulnerability assessment to identify vulnerabilties and prepare for the exploitation phase.

- Automatic scanners:
 - Nessus
 - OpenVAS
 - Nexpose
 - GFI LAN Guard    

- Manual testing
  •Learning and understanding its features
  •Understanding how it exchanges data over the network
  •Understanding how it accesses resources like databases, servers, local and remote files and so on
  •Reverse engineering its logic


    
    
    
    
    
    
    
    
    
    
    
    
